# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['nemo_bo',
 'nemo_bo.acquisition_functions',
 'nemo_bo.acquisition_functions.expected_improvement',
 'nemo_bo.acquisition_functions.highest_uncertainty',
 'nemo_bo.acquisition_functions.nsga_improvement',
 'nemo_bo.models',
 'nemo_bo.models.base',
 'nemo_bo.opt',
 'nemo_bo.opt.utils_samplers',
 'nemo_bo.utils']

package_data = \
{'': ['*']}

install_requires = \
['attrs>=21.4.0,<22.0.0',
 'botorch>=0.7.0,<0.8.0',
 'cython>=0.29.30,<0.30.0',
 'forestci>=0.5.1,<0.6.0',
 'gpytorch>=1.8.1,<2.0.0',
 'hyperopt>=0.2.7,<0.3.0',
 'matplotlib>=3.5.2,<4.0.0',
 'ngboost>=0.3.12,<0.4.0',
 'numba>=0.55.1,<0.56.0',
 'numpy>=1.22.4,<2.0.0',
 'openpyxl>=3.0.9,<4.0.0',
 'pandas>=1.4.2,<2.0.0',
 'pydoe2>=1.3.0,<2.0.0',
 'pymoo>=0.6.0,<0.7.0',
 'scikit-learn>=1.1.1,<2.0.0',
 'scipy>=1.8.1,<2.0.0',
 'six>=1.16.0,<2.0.0',
 'tensorflow-probability>=0.17.0,<0.18.0',
 'tensorflow>=2.9.1,<3.0.0',
 'torch>=1.11.0,<2.0.0',
 'xgboost-distribution>=0.2.4,<0.3.0']

setup_kwargs = {
    'name': 'nemo-bo',
    'version': '0.1.14',
    'description': 'Multi-objective optimization of chemical processes with automated machine learning workflows',
    'long_description': '# Nomadic Exploratory Multi-objective Optimisation (NEMO)\n\nMeet NEMO - our ‘Nomadic Explorer’. NEMO is quite the connoisseur when it comes to machine learning optimisation - only the best model types and model parameters will suffice. In the case of a single dataset, NEMO will scour the lands for the optimal model type and parameters to fit a given dataset. A range of outputs will then be generated for you to assess, interpret and utilise your newly created model.\n\nIf you decide to take your analyses a step further into the realms of Multi-objective Bayesian optimisation, then our Nomadic Explorer will tirelessly search for the best model type and parameters at each iteration of the optimisation. At each stage, the optimal set of conditions will be provided to aid your pursuit of the elusive multi-dimensional pareto front.\n\nNEMO is prepared for the journey with a cavernous bag of tools. However, if your aspirations are more exotic, then NEMO supports the inclusion of custom models, samplers and functions.\n\nCheck out the examples to see NEMO in action and get started with your own ML workflows.\n\n## What is NEMO?\n\nNEMO is a package designed for Bayesian optimisation of one or multiple objectives simultaneously, with a focus on applying to chemical processes.\n\n## Installation\nTo install NEMO via pip:\n\n`pip install nemo-bo`\n\n\n## How does NEMO work?\n\nFirstly, the parameters (variables) and targets (objectives) of a chemical process are provided to the algorithm. After \nproviding NEMO with a dataset from prior experiments, it will then identify the relationship between the parameters and targets \nand then suggest the ideal parameters to use for the optimisation iteration.\n\nIn comparison to other open-source optimisation libraries, NEMO will automatically optimise the hyperparameters for \nvarious machine learning models and select the one with the best predictive accuracy for a given objective. This \nensures that the model is continuously optimised over the course of an optimisation campaign. Furthermore, NEMO \nnatively supports objectives that can be calculated if the exact relationship between the parameters and the target \n(e.g. materials cost) is known.\n\n## What features are in NEMO?\nAlthough NEMO includes many machine learning models, acquisition functions, constraints, and sample generators, the \nbase classes for these are all included and can be utilised as a template for adding your own custom solutions.\n\nThe features natively found in NEMO are the following:\n\n### Machine learning models available\n1. Gaussian processes (GPs) using the [BoTorch](https://github.com/pytorch/botorch) library\n\n2. Various neural networks from the [Deeply Uncertain code repository](https://github.com/deepskies/DeeplyUncertain-Public):\n   1. Bayesian neural networks\n   2. Concrete dropout\n   3. Deep ensembles\n\n3. Various decision-tree based models:\n   1. [XGBoost Distribution](https://github.com/CDonnerer/xgboost-distribution)\n   2. [NGBoost](https://github.com/stanfordmlgroup/ngboost)\n   3. Random Forest using the [forest-confidence-interval](https://github.com/scikit-learn-contrib/forest-confidence-interval)\n\n### Variable types available\n1. Continuous variables (`ContinuousVariable`)\n2. Categorical variables with discrete variables (`CategoricalVariableDiscreteValues`)\n3. Categorical variables with descriptors (`CategoricalVariableWithDescriptors`)\n\nCategorical variables without any description (e.g. one-hot encoding) is not currently supported\n\n### Objective types available\n1. Objectives modelled using machine learning models (`RegressionObjective`)\n2. Calculated objectives using a user-provided function (`CalculableObjective`)\n\nClassification objectives are not currently supported\n\n### User-selectable acquisition functions available\n1. Expected improvement based methods (`ExpectedImprovement`)\n   1. A modifed single-objective expected improvement algorithm that is better at exploration than the standard analytical method\n   2. A modifed multi-objective expected hypervolume improvement algorithm that is better at exploration than the standard analytical method\n   3. [qNEI](https://botorch.org/api/_modules/botorch/acquisition/monte_carlo.html#qNoisyExpectedImprovement) and [qNEHVI](https://botorch.org/api/_modules/botorch/acquisition/multi_objective/monte_carlo.html#qNoisyExpectedHypervolumeImprovement) BoTorch methods (only compatible with GP models)\n\n2. A Unified evolutionary optimization algorithm [U-NSGA-III](https://pymoo.org/algorithms/moo/unsga3.html) based method that derives uncertainty in the inference by sampling from a distribution (`NSGAImprovement`)\n3. A fully explorative method that identifies the candidates that have the highest uncertainty in the objective predictions (`HighestUncertainty`)\n\n### Input constraints available\n1. Linear equality and inequality constraints(`LinearConstraint`)\n2. Basic non-linear equality and inequality constraints that incorporates an exponent for each input variable (`NonLinearPowerConstraint`)\n3. Equality and inequality constraints that allows the user to pass a function to calculate the left-hand-side of the constraint (`FunctionalConstraint`)\n4. Stoichiometry constraints that forces the ratio between two input variable to be equal to or greater than a specified value (`StoichiometricConstraint`)\n5. A constraint type to limit the number of active variables (`MaxActiveFeaturesConstraint`)\n6. A constraint type that prevents certain categorical constraints from being selected simulatenously (`CategoricalConstraint`)\n\n### Benchmarking functionality available\nBenchmark functions are typically used to simulate the outcomes of experiments in a closed-loop manner and therefore\ncan be helpful to evaluate the quality of an optimisation (inferred from the effectiveness of the utilised model(s) \nand/or acquisition function to identify the optimum)\n\n1. Machine learning model based on a provided dataset (`ModelBenchmark`)\n2. Single objective synthetic functions (`SingleObjectiveSyntheticBenchmark`)\n3. Multi-objective synthetic functions (`MultiObjectiveSyntheticBenchmark`)\n\n### Sample generators available\nMethods for generating a samples of parameter values during an optimisation. These can be used independently outside of an optimisation too by calling the `generate_samples` function\n\n1. Latin hypercube sampling (with a mixed-integer implementation for efficient sampling of categorical variables) (`LatinHyperCubeSampling`)\n2. Sobol sampling (`SobolSampling`)\n3. Polytope sampling (`PolytopeSampling`)\n4. Random sampling (`RandomSampling`)\n5. Pool-based sampling using a user-defined set of data points. Typically used as an alternative to a machine learning model benchmark function (`PoolBased`)\n\n### Other utilities/functions available\n1. Included template for provided the dataset with automated extraction\n2. Scatter and bar chart plotting functionality for displaying model quality and optimisation progress\n\n\n## Getting started\nThe following code demonstrates how to set-up a simple bayesian optimisation using a user-provided dataset containing four continuous variables (X) and two objectives (Y):\n\n```python\n# Import the variable, objectives, sampler, acquisition function, and the optimisation classes\nimport numpy as np\nfrom nemo_bo.opt.variables import ContinuousVariable, VariablesList\nfrom nemo_bo.opt.objectives import RegressionObjective, ObjectivesList\nfrom nemo_bo.acquisition_functions.expected_improvement.expected_improvement import ExpectedImprovement\nfrom nemo_bo.opt.samplers import LatinHyperCubeSampling\nfrom nemo_bo.opt.optimisation import Optimisation\n\n# Create the variable objects\nvar1 = ContinuousVariable(name="variable1", lower_bound=1.0, upper_bound=10.0)\nvar2 = ContinuousVariable(name="variable2", lower_bound=0.02, upper_bound=0.2)\nvar3 = ContinuousVariable(name="variable1", lower_bound=30.0, upper_bound=70.0)\nvar4 = ContinuousVariable(name="variable2", lower_bound=5.0, upper_bound=15.0)\nvar_list = VariablesList([var1, var2, var3, var4])\n\n# Create the objective objects\nobj1 = RegressionObjective(\n    name="objective1", # obj_max_bool when True defines the objective is to be maximised\n    obj_max_bool=True,\n    lower_bound=0.0,\n    upper_bound=100.0,\n    predictor_type=["gp", "xgb"],\n)\nobj2 = RegressionObjective(\n    name="objective2",\n    obj_max_bool=False, # obj_max_bool when False defines the objective is to be minimised\n    lower_bound=0.01,\n    upper_bound=0.15,\n    predictor_type=["gp", "xgb"],\n)\nobj_list = ObjectivesList([obj1, obj2])\n\n# Instantiate the sampler\nsampler = LatinHyperCubeSampling()\n\n# Instantiate the acquisition function\nacq_func = ExpectedImprovement(num_candidates=4) # num_candidates defines how many sets of parameters to return at each optimisation iteration\n\n# Set up the optimisation instance\noptimisation = Optimisation(var_list, obj_list, acq_func, sampler=sampler)\n\n# Start the optimisation using the convenient run function that will run for the specified number of iterations\n# X and Y arrays represent an initial user-provided dataset\nX = np.array(\n    [\n        [6.82, 0.16, 34, 6.2],\n        [6.15, 0.08, 47, 8.5],\n        [4.92, 0.05, 32, 11.1],\n        [9.24, 0.15, 41, 12.1],\n        [1.07, 0.12, 67, 8.2],\n        [5.66, 0.09, 53, 12.7],\n        [8.08, 0.19, 54, 5.4],\n        [1.87, 0.11, 68, 9.2],\n        [4.08, 0.13, 58, 10.4],\n        [4.38, 0.18, 36, 14.6],\n    ]\n)\nY = np.array(\n    [\n        [33.31, 0.12],\n        [41.89, 0.10],\n        [36.87, 0.09],\n        [46.32, 0.13],\n        [0.00, 0.09],\n        [36.52, 0.10],\n        [45.77, 0.14],\n        [0.00, 0.09],\n        [30.95, 0.11],\n        [34.89, 0.12],\n    ]\n)\noptimisation_data = optimisation.run(X, Y, number_of_iterations=10)\n```\n\n## More tutorials\nWe encourage you to look through the tutorials written in the `tutorials` folder to see how to use some other \nNEMO functions\n1. How to select specific machine learning models types for the objectives\n2. Setting up a single objective optimisation\n3. How to use calculable objectives\n4. How to define transformers for variables and objectives\n5. How to define categorical variables with descriptors\n6. Utilising the machine learning model fitting in NEMO without Bayesian optimisation\n7. How to create a closed-loop optimisation using a machine learning model as the benchmark function\n8. How to create a closed-loop optimisation using a multiobjective synthetic function as the benchmark function\n9. How to create a closed-loop optimisation using a single objective synthetic function as the benchmark function\n10. How to create a closed-loop optimisation using a pool-based sampler as the benchmark\n11. Setting up an optimisation with input constraints\n12. Generating samples without needing to perform an optimisation\n13. How to set up a manual optimisation\n14. How to resume an optimisation run\n15. How to use the BoTorch (quasi-) Monte-Carlo based acquisition functions in NEMO\n16. How to set up an optimisation that uses U-NSGA-III as the acquisition function\n17. Using the input template excel file template to import the variables and objectives data\n18. How to set up an optimisation that uses the highest uncertainty acquisition function\n\n\n## What to do if you find any issues?\nLeave a message in the issues section and we will get back to you as soon as we can.\n\n\n## Acknowledgements\nMuch of the functionality in NEMO is built on top of the work by the authors of the features we incorporate. We are grateful \nto them for continuously supporting their libraries and establishing their platforms for optimisation work. We reference \nthe works throughout the .py files.\n',
    'author': 'Simon Sung',
    'author_email': 'simon.sung06@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/sustainable-processes/nemo-bo',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9.0,<=3.9.13',
}


setup(**setup_kwargs)
