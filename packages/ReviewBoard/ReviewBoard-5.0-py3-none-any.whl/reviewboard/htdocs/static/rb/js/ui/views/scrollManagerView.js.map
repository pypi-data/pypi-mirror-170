{"version":3,"file":"scrollManagerView.js","names":["RB","ScrollManagerView","Backbone","View","extend","initialize","scrollYOffset","window","_updateScrollPosScheduled","_pendingElements","Map","_elements","_oldScrollY","_useScrollYOffset","scrollToElement","$el","scrollToPosition","offset","top","scrollY","scrollTo","pageXOffset","history","scrollRestoration","_scheduleUpdateScrollPos","markForUpdate","console","assert","length","oldOffset","set","oldHeight","outerHeight","left","pageYOffset","markUpdated","el","elInfo","get","newHeight","newOffset","delete","requestAnimationFrame","_updateScrollPos","bind","elInfos","forEach","newHeighht","push","sort","a","b","i","clear","scrollManager"],"sources":["../../../../../../static/rb/js/ui/views/scrollManagerView.es6.js"],"sourcesContent":["/**\n * Manages behavior and UI related to scrolling the page.\n *\n * This can be used by the UI to track pending and completed updates to\n * elements that might affect the current scroll position, such as new content\n * being injected into the DOM or being hidden/shown. When such updates occur\n * that would cause a page jump, the scroll manager will fix the scroll\n * position to counteract the jump.\n *\n * When a view is ready to make a DOM change that would impact the display or\n * size of an element, it should call\n * :js:func:`RB.ScrollManagerView.markForUpdate` before updating the element.\n * After, it should call :js:func:`RB.ScrollManagerView.markUpdates`.\n *\n * Views that create floating elements at the top of the page (such as banners)\n * should increment :js:attr:`RB.ScrollManagerView.scrollYOffset` by the height\n * of the element, and decrement it when the element goes away. This will\n * ensure that when navigating to an element through the scroll manager that\n * the height of the floating element will be taken into consideration for\n * the positioning.\n *\n * Attributes:\n *     scrollYOffset (number):\n *         The offset to add when scrolling to a target element or position.\n *         Callers should only increment or decrement this, and should never\n *         set it directly.\n */\nRB.ScrollManagerView = Backbone.View.extend({\n    /**\n     * Initialize the scroll manager.\n     */\n    initialize() {\n        this.scrollYOffset = 0;\n\n        // This is used so that unit tests can create a dummy window.\n        this.window = window;\n\n        this._updateScrollPosScheduled = false;\n        this._pendingElements = new Map();\n        this._elements = new Map();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n    },\n\n    /**\n     * Scroll to a specific element on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element to scroll to.\n     */\n    scrollToElement($el) {\n        this.scrollToPosition($el.offset().top);\n    },\n\n    /**\n     * Scroll to a specific position on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     scrollY (number):\n     *         The Y position to scroll to.\n     */\n    scrollToPosition(scrollY) {\n        this._oldScrollY = scrollY;\n\n        /*\n         * We use this instead of a flag being passed around to functions\n         * because we might actually end up using a pre-scheduled update to\n         * the scroll position, rather than scheduling a new one.\n         */\n        this._useScrollYOffset = true;\n\n        /* Attempt to immedialely scroll to the desired position. */\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        /*\n         * Chrome (and possibly other browsers in the future) attempt to be\n         * smart about restoring the initial scroll position after the page\n         * has fully loaded. However, we want to control the position in this\n         * case (probably in response to something in the URL we're handling),\n         * so we want to disable Chrome's behavior. Fortunately, there's an\n         * API for that.\n         */\n        if ('scrollRestoration' in history) {\n            history.scrollRestoration = 'manual';\n        }\n\n        this._scheduleUpdateScrollPos(true);\n    },\n\n    /**\n     * Mark an element for update.\n     *\n     * This should be called when an element will be updated with new\n     * content/size/visibility. The current state of the element will be\n     * tracked. When the update has finished, :js:func:`markUpdated` should\n     * be called to finalize the update.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element being updated.\n     */\n    markForUpdate($el) {\n        console.assert($el.length === 1);\n\n        const oldOffset = $el.offset();\n\n        this._pendingElements.set($el[0], {\n            oldHeight: $el.outerHeight(),\n            oldOffset: {\n                left: oldOffset.left,\n                top: oldOffset.top,\n            },\n        });\n\n        if (this._oldScrollY === null) {\n            this._oldScrollY = this.window.pageYOffset;\n        }\n    },\n\n    /**\n     * Mark an element as having been updated.\n     *\n     * This will schedule a scroll position update, factoring in the size\n     * and position differences for the element and helping prevent a page\n     * jump if the update occurred before the current scroll position.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element that was updated.\n     */\n    markUpdated($el) {\n        console.assert($el.length === 1);\n\n        const el = $el[0];\n        const elInfo = this._pendingElements.get(el);\n\n        if (elInfo) {\n            elInfo.newHeight = $el.outerHeight();\n            elInfo.newOffset = $el.offset();\n\n            this._elements.set(el, elInfo);\n            this._pendingElements.delete(el);\n        }\n\n        this._scheduleUpdateScrollPos();\n    },\n\n    /**\n     * Schedule an update for the scroll position.\n     *\n     * This will schedule the scroll position to be updated to take into\n     * account any updated elements. The update will happen in the next\n     * available animation frame. Only one will ever be scheduled at a time.\n     */\n    _scheduleUpdateScrollPos() {\n        if (!this._updateScrollPosScheduled) {\n            this._updateScrollPosScheduled = true;\n\n            /*\n             * Ideally we would update the DOM and set the scroll position at\n             * the same time, synchronized, without waiting for an animation\n             * frame and preventing any kind of a jump. This would work okay\n             * in some browsers (Chrome and Firefox are pretty good at not\n             * jumping), but some -- Safari (as of 10.1), Internet Explorer\n             * (as of 11), and Edge (as of 38.14393) -- will still jump after\n             * our code executes.\n             *\n             * We can minimize that jump by performing the scroll update during\n             * an animation frame, getting it as close as possible to the DOM\n             * layout update.\n             */\n            this.window.requestAnimationFrame(\n                this._updateScrollPos.bind(this));\n        }\n    },\n\n    /**\n     * Update the scroll position to factor in any element updates.\n     *\n     * This will look for any tracked elements that have been updated\n     * earlier in the page (before the current scroll position). It will\n     * then update the scroll position to take those updates into account,\n     * helping prevent a page jump.\n     */\n    _updateScrollPos() {\n        const elInfos = [];\n\n        this._elements.forEach((elInfo, el) => {\n            /*\n             * Check if the element remained the same size. We can ignore\n             * these.\n             */\n            if (elInfo.oldHeight !== elInfo.newHeighht) {\n                elInfo.el = el;\n                elInfos.push(elInfo);\n            }\n        });\n\n        let scrollY = this._oldScrollY;\n\n        if (this._useScrollYOffset) {\n            scrollY -= this.scrollYOffset;\n        }\n\n        if (elInfos.length > 0) {\n            /* Try to put these in order by position. */\n            elInfos.sort((a, b) => a.newOffset.top - b.newOffset.top);\n\n            for (let i = 0; i < elInfos.length; i++) {\n                const elInfo = elInfos[i];\n\n                /* Check if the element precedes the current scroll position. */\n                if (elInfo.newOffset.top + elInfo.newHeight < scrollY) {\n                    scrollY += (elInfo.newHeight - elInfo.oldHeight) +\n                               (elInfo.newOffset.top - elInfo.oldOffset.top);\n                }\n            }\n        }\n\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        this._elements.clear();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n        this._updateScrollPosScheduled = false;\n    },\n});\n\n\nRB.scrollManager = new RB.ScrollManagerView();\n"],"mappings":"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"}