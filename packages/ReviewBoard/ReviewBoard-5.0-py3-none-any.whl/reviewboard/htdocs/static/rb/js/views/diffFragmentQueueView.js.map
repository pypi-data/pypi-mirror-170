{"version":3,"file":"diffFragmentQueueView.js","names":["RB","DiffFragmentQueueView","Backbone","View","extend","initialize","options","_containerPrefix","containerPrefix","_diffFragmentViewOptions","diffFragmentViewOptions","_fragmentsBasePath","reviewRequestPath","_queueName","queueName","_queue","_saved","queueLoad","commentID","key","onFragmentRendered","queue","push","saveFragment","$el","_getCommentContainer","length","data","html","loadFragments","onDone","_","isEmpty","isFunction","each","queuedLoads","$","funcQueue","add","pendingCommentIDs","onFragmentRenderedFuncs","i","queuedLoad","hasOwnProperty","container","console","assert","view","render","_renderFragment","_loadDiff","join","next","start","commentIDs","queryArgs","linesOfContext","undefined","includes","TEMPLATE_SERIAL","apiCall","url","dataType","type","success","arrayBuffer","dataView","DataView","len","byteLength","pos","totalFragments","totalRenders","done","onFragmentLoaded","containerID","$container","error","parsed","_parseDiffFragmentFromPayload","load","getUint32","htmlLen","htmlStart","cb","DataUtils","readBlobAsString","Blob","slice","scrollManager","markForUpdate","DiffFragmentView","defaults","el","loadDiff","setActivityIndicator","markUpdated"],"sources":["../../../../../static/rb/js/views/diffFragmentQueueView.es6.js"],"sourcesContent":["/**\n * Queues loading of diff fragments from a page.\n *\n * This is used to load diff fragments one-by-one, and to intelligently\n * batch the loads to only fetch at most one set of fragments per file.\n */\nRB.DiffFragmentQueueView = Backbone.View.extend({\n    /**\n     * Initialize the queue.\n     *\n     * Args:\n     *     options (object):\n     *         Options passed to this view.\n     *\n     * Returns:\n     *     containerPrefix (string):\n     *         The prefix to prepend to diff comment IDs when forming\n     *         container element IDs.\n     *\n     *     diffFragmentViewOptions (object, optional):\n     *         Options to pass to each :js:class:`RB.DiffFragmentView` that's\n     *         created.\n     *\n     *     reviewRequestPath (string):\n     *         The URL for the review request that diff fragments will be\n     *         loaded from.\n     *\n     *     queueName (string):\n     *         The name of the diff loading queue.\n     */\n    initialize(options) {\n        this._containerPrefix = options.containerPrefix;\n        this._diffFragmentViewOptions = options.diffFragmentViewOptions;\n        this._fragmentsBasePath =\n            `${options.reviewRequestPath}_fragments/diff-comments/`;\n        this._queueName = options.queueName;\n\n        this._queue = {};\n        this._saved = {};\n    },\n\n    /**\n     * Queue the load of a diff fragment from the server.\n     *\n     * This will be added to a list, which will fetch the comments in batches\n     * based on file IDs.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to queue.\n     *\n     *     key (string):\n     *         The key for the queue. Each comment with the same key will be\n     *         loaded in a batch. This will generally be the ID of a file.\n     *\n     *     onFragmentRendered (function, optional):\n     *         Optional callback for when the view for the fragment has\n     *         rendered. Contains the view as a parameter.\n     */\n    queueLoad(commentID, key, onFragmentRendered) {\n        const queue = this._queue;\n\n        if (!queue[key]) {\n            queue[key] = [];\n        }\n\n        queue[key].push({\n            commentID: commentID,\n            onFragmentRendered: onFragmentRendered || null,\n        });\n    },\n\n    /**\n     * Save a comment's loaded diff fragment for the next load operation.\n     *\n     * If the comment's diff fragment was already loaded, it will be\n     * temporarily stored until the next load operation involving that\n     * comment. Instead of loading the fragment from the server, the saved\n     * fragment's HTML will be used instead.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to save.\n     */\n    saveFragment(commentID) {\n        const $el = this._getCommentContainer(commentID);\n\n        if ($el.length === 1 && $el.data('diff-fragment-view')) {\n            this._saved[commentID] = $el.html();\n        }\n    },\n\n    /**\n     * Load all queued diff fragments.\n     *\n     * The diff fragments for each keyed set in the queue will be loaded as\n     * a batch. The resulting fragments will be injected into the DOM.\n     *\n     * Any existing fragments that were saved will be loaded from the cache\n     * without requesting them from the server.\n     *\n     * Args:\n     *     onDone (function, optional):\n     *         Callback for when all fragments have been loaded.\n     */\n    loadFragments(onDone) {\n        if (_.isEmpty(this._queue) && _.isEmpty(this._saved)) {\n            if (_.isFunction(onDone)) {\n                onDone();\n            }\n\n            return;\n        }\n\n        const queueName = this._queueName;\n\n        _.each(this._queue, queuedLoads => {\n            $.funcQueue(queueName).add(() => {\n                const pendingCommentIDs = [];\n                const onFragmentRenderedFuncs = {};\n\n                /*\n                 * Check if there are any comment IDs that have been saved.\n                 * We don't need to reload these from the server.\n                 */\n                for (let i = 0; i < queuedLoads.length; i++) {\n                    const queuedLoad = queuedLoads[i];\n                    const commentID = queuedLoad.commentID;\n                    const onFragmentRendered =\n                        _.isFunction(queuedLoad.onFragmentRendered)\n                        ? queuedLoad.onFragmentRendered\n                        : null;\n\n                    if (this._saved.hasOwnProperty(commentID)) {\n                        const html = this._saved[commentID];\n\n                        const container = this._getCommentContainer(commentID);\n                        console.assert(container);\n\n                        let view = container.data('diff-fragment-view');\n\n                        if (view) {\n                            view.$el.html(html);\n                            view.render();\n                        } else {\n                            view = this._renderFragment(container, commentID,\n                                                        html);\n                        }\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(view);\n                        }\n\n                        delete this._saved[commentID];\n                    } else {\n                        pendingCommentIDs.push(commentID);\n                        onFragmentRenderedFuncs[commentID] =\n                            onFragmentRendered;\n                    }\n                }\n\n                if (pendingCommentIDs.length > 0) {\n                    /*\n                     * There are some comment IDs we don't have. Load these\n                     * from the server.\n                     *\n                     * Once these are loaded, they'll call next() on the queue\n                     * to process the next batch.\n                     */\n                    this._loadDiff(pendingCommentIDs.join(','), {\n                        queueName: queueName,\n                        onFragmentRendered: (commentID, view) => {\n                            if (onFragmentRenderedFuncs[commentID]) {\n                                onFragmentRenderedFuncs[commentID](view);\n                            }\n                        },\n                        onDone: () => $.funcQueue(queueName).next(),\n                    });\n                } else {\n                    /*\n                     * We processed all we need to process above. Go to the\n                     * next queue.\n                     */\n                    $.funcQueue(queueName).next();\n                }\n            });\n        });\n\n        if (_.isFunction(onDone)) {\n            $.funcQueue(queueName).add(() => {\n                onDone();\n                $.funcQueue(queueName).next();\n            });\n        }\n\n        // Clear the list.\n        this._queue = {};\n\n        $.funcQueue(queueName).start();\n    },\n\n    /**\n     * Return the container for a particular comment.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment.\n     *\n     * Returns:\n     *     jQuery:\n     *     The comment container, wrapped in a jQuery element. The caller\n     *     may want to check the length to be sure the container was found.\n     */\n    _getCommentContainer(commentID) {\n        return $(`#${this._containerPrefix}_${commentID}`);\n    },\n\n    /**\n     * Load a diff fragment for the given comment IDs and options.\n     *\n     * This will construct the URL for the relevant diff fragment and load\n     * it from the server.\n     *\n     * Args:\n     *     commentIDs (string):\n     *         A string of comment IDs to load fragments for.\n     *\n     *     options (object, optional):\n     *         Options for the loaded diff fragments.\n     *\n     * Option Args:\n     *     linesOfContext (string):\n     *         The lines of context to load for the diff. This is a string\n     *         containing a comma-separated set of line counts in the form\n     *         of ``numLinesBefore,numLinesAfter``.\n     *\n     *     onDone (function):\n     *         A function to call after the diff has been loaded.\n     *\n     *     queueName (string):\n     *         The name of the load queue. This is used to load batches of\n     *         fragments sequentially.\n     */\n    _loadDiff(commentIDs, options={}) {\n        const containerPrefix = this._containerPrefix;\n        const queryArgs = [];\n        const onFragmentRendered = (_.isFunction(options.onFragmentRendered)\n                                    ? options.onFragmentRendered\n                                    : null);\n\n        if (options.linesOfContext !== undefined) {\n            queryArgs.push(`lines_of_context=${options.linesOfContext}`);\n        }\n\n        if (!containerPrefix.includes('draft')) {\n            queryArgs.push('allow_expansion=1');\n        }\n\n        queryArgs.push(TEMPLATE_SERIAL);\n\n        RB.apiCall({\n            url: `${this._fragmentsBasePath}${commentIDs}/`,\n            data: queryArgs.join('&'),\n            dataType: 'arraybuffer',\n            type: 'GET',\n            success: arrayBuffer => {\n                const dataView = new DataView(arrayBuffer);\n                const len = dataView.byteLength;\n                let pos = 0;\n                let totalFragments = 0;\n                let totalRenders = 0;\n                let done = false;\n\n                const onFragmentLoaded = (commentID, html) => {\n                    /* Set the HTML in the container. */\n                    const containerID = `#${containerPrefix}_${commentID}`;\n                    const $container = $(containerID);\n\n                    if ($container.length === 0) {\n                        /*\n                         * This doesn't actually exist. We may be dealing with\n                         * inconsistent state due to something missing in the\n                         * database. We don't want to break the page if this\n                         * happens, so log and skip the entry.\n                         */\n                        console.error('Unable to find container %s for ' +\n                                      'comment ID %s. There may be missing ' +\n                                      'state in the database.',\n                                      containerID, commentID);\n                    } else {\n                        const view = this._renderFragment(\n                            $(`#${containerPrefix}_${commentID}`),\n                            commentID,\n                            html);\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(commentID, view);\n                        }\n                    }\n\n                    totalRenders++;\n\n                    if (done && totalRenders === totalFragments &&\n                        _.isFunction(options.onDone)) {\n                        /*\n                         * We've parsed and rendered all fragments, so we're\n                         * officially done.\n                         */\n                        options.onDone();\n                    }\n                }\n\n                while (!done) {\n                    const parsed = this._parseDiffFragmentFromPayload(\n                        arrayBuffer, dataView, pos);\n\n                    totalFragments++;\n                    pos = parsed.pos;\n                    done = (pos >= len);\n\n                    parsed.load(onFragmentLoaded);\n                }\n            }\n        });\n    },\n\n    /**\n     * Parse a single diff fragment from the payload.\n     *\n     * This will parse out information about the fragment (the comment ID and\n     * HTML) and return a response containing the new position and a function\n     * to call in order to load the parsed fragment.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the fragment content. This takes a\n     *         callback function as an argument containing ``commentID`` and\n     *         ``html`` arguments.\n     */\n    _parseDiffFragmentFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the comment ID. */\n        const commentID = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the length of the HTML. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the HTML position for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                RB.DataUtils.readBlobAsString(\n                    new Blob([arrayBuffer.slice(htmlStart,\n                                                htmlStart + htmlLen)]),\n                    html => cb(commentID, html));\n            },\n        };\n    },\n\n    /**\n     * Render a diff fragment on the page.\n     *\n     * This will set up a view for the diff fragment, if one is not already\n     * created, and render it on the page.\n     *\n     * It will also mark the fragment for updates with the scroll manager\n     * so that if the user is scrolled to a location past the fragment, the\n     * resulting size change for the fragment won't cause the page to jump.\n     *\n     * Args:\n     *     $container (jQuery):\n     *         The container element where the fragment will be injected.\n     *\n     *     commentID (number):\n     *         The ID of the comment.\n     *\n     *     html (string):\n     *         The HTML contents of the fragment.\n     */\n    _renderFragment($container, commentID, html) {\n        RB.scrollManager.markForUpdate($container);\n\n        $container.html(html);\n\n        let view = $container.data('diff-fragment-view');\n\n        if (!view) {\n            view = new RB.DiffFragmentView(_.defaults({\n                el: $container,\n                loadDiff: options => {\n                    RB.setActivityIndicator(true, {type: 'GET'});\n\n                    this._loadDiff(commentID, _.defaults({\n                        onDone() {\n                            RB.setActivityIndicator(false, {});\n\n                            if (options.onDone) {\n                                options.onDone();\n                            }\n                        },\n                    }, options));\n                },\n            }, this._diffFragmentViewOptions));\n            $container.data('diff-fragment-view', view);\n        }\n\n        view.render();\n\n        RB.scrollManager.markUpdated($container);\n\n        return view;\n    },\n});\n"],"mappings":"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"}