{"version":3,"file":"reviewRequestPageModel.js","names":["RB","ReviewRequestPage","ReviewablePage","extend","defaults","_","updatesURL","prototype","initialize","apply","arguments","_watchedEntries","_watchedUpdatesPeriodMS","_watchedUpdatesTimeout","_watchedUpdatesLastScheduleTime","entries","Backbone","Collection","model","Entry","parse","rsp","call","addEntry","entry","set","add","watchEntryUpdates","periodMS","Date","now","clearTimeout","id","_scheduleCheckUpdates","stopWatchingEntryUpdates","hasOwnProperty","isEmpty","key","Math","min","setTimeout","_loadUpdates","pluck","onDone","bind","options","get","allEntryIDs","urlQuery","length","i","typeID","push","urlEntryTypeIDs","entryTypeID","sort","a","b","entryIDs","join","urlQueryStr","sync","url","dataType","noActivityIndicator","success","arrayBuffer","_processUpdatesFromPayload","dataView","DataView","len","byteLength","pos","totalUpdates","totalApplied","done","onUpdateLoaded","metadata","html","type","_processEntryUpdate","_reloadFromUpdate","trigger","isFunction","parsed","_processUpdateFromPayload","load","metadataLen","getUint32","metadataStart","htmlLen","htmlStart","cb","metadataBlob","Blob","slice","htmlBlob","DataUtils","readManyBlobsAsStrings","JSON","entryID","console","assert","entryType","isUpdated","beforeApplyUpdate","attributes","modelData","etag","updatedTimestamp","afterApplyUpdate"],"sources":["../../../../../../static/rb/js/reviewRequestPage/models/reviewRequestPageModel.es6.js"],"sourcesContent":["/**\n * Model for the review request page.\n *\n * This manages state specific to the review request page, and handles\n * watching for server-side updates relevant to entries and UI on the page.\n */\nRB.ReviewRequestPage.ReviewRequestPage = RB.ReviewablePage.extend({\n    defaults: _.defaults({\n        updatesURL: null,\n    }, RB.ReviewablePage.prototype.defaults),\n\n    /**\n     * Initialize the model.\n     */\n    initialize() {\n        RB.ReviewablePage.prototype.initialize.apply(this, arguments);\n\n        this._watchedEntries = {};\n        this._watchedUpdatesPeriodMS = null;\n        this._watchedUpdatesTimeout = null;\n        this._watchedUpdatesLastScheduleTime = null;\n\n        this.entries = new Backbone.Collection([], {\n            model: RB.ReviewRequestPage.Entry,\n        });\n    },\n\n    /**\n     * Parse the data for the page.\n     *\n     * This will take data from the server and turn it into a series of\n     * objects and attributes needed for parts of the page.\n     *\n     * Args:\n     *     rsp (object):\n     *         The incoming data provided for the page.\n     *\n     * Returns:\n     *     object:\n     *     The resulting attributes for the page.\n     */\n    parse(rsp) {\n        return _.extend({\n            updatesURL: rsp.updatesURL,\n        }, RB.ReviewablePage.prototype.parse.call(this, rsp));\n    },\n\n    /**\n     * Add an entry to the page.\n     *\n     * The entry's ``page`` attribute will be set to this page, for reference,\n     * and then the entry will be added to the ``entries`` collection.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry to add.\n     */\n    addEntry(entry) {\n        entry.set('page', this);\n        this.entries.add(entry);\n    },\n\n    /**\n     * Watch for updates to an entry.\n     *\n     * The entry will be checked for updates at least once every ``periodMS``\n     * milliseconds.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     *\n     *     periodMS (number):\n     *         The frequency at which the updates should be polled. Updates\n     *         will be checked at least this often.\n     */\n    watchEntryUpdates(entry, periodMS) {\n        /*\n         * If we already have a check in progress, and this new update\n         * request wants to check sooner than the current check is scheduled,\n         * then disconnect the old timer so we can reconnect it with the new\n         * delay.\n         */\n        if (this._watchedUpdatesPeriodMS === null ||\n            periodMS < this._watchedUpdatesPeriodMS) {\n            /*\n             * This is either the only update requested, or it's more frequent\n             * than other ones. Now we just need to check if we need to cancel\n             * any previous update checks that are scheduled later than the\n             * new check would be.\n             */\n            if (this._watchedUpdatesTimeout !== null &&\n                (Date.now() -\n                 this._watchedUpdatesLastScheduleTime) > periodMS) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesPeriodMS = periodMS;\n        }\n\n        this._watchedEntries[entry.id] = {\n            entry: entry,\n            periodMS: periodMS,\n        };\n\n        this._scheduleCheckUpdates();\n    },\n\n    /**\n     * Stop watching for updates to an entry.\n     *\n     * Args:\n     *     entry (RB.ReviewRequestPage.Entry):\n     *         The entry being watched for updates.\n     */\n    stopWatchingEntryUpdates(entry) {\n        if (!this._watchedEntries.hasOwnProperty(entry.id)) {\n            return;\n        }\n\n        delete this._watchedEntries[entry.id];\n\n        /*\n         * We'll either be clearing this for now, or recomputing. Either way,\n         * we want this null for the next steps.\n         */\n        this._watchedUpdatesPeriodMS = null;\n\n        if (_.isEmpty(this._watchedEntries)) {\n            /*\n             * There's nothing left to watch, so cancel the timeout (if set)\n             * and clear state.\n             */\n            if (this._watchedUpdatesTimeout !== null) {\n                clearTimeout(this._watchedUpdatesTimeout);\n                this._watchedUpdatesTimeout = null;\n            }\n\n            this._watchedUpdatesLastScheduleTime = null;\n        } else {\n            /*\n             * There's still other entries being watched. We need to\n             * update state accordingly.\n             *\n             * We'll let any current timeouts continue as-is.\n             */\n            for (let key in this._watchedEntries) {\n                if (this._watchedEntries.hasOwnProperty(key)) {\n                    const periodMS = this._watchedEntries[key].periodMS;\n\n                    this._watchedUpdatesPeriodMS =\n                        (this._watchedUpdatesPeriodMS === null\n                         ? periodMS\n                         : Math.min(this._watchedUpdatesPeriodMS, periodMS));\n                }\n            }\n        }\n    },\n\n    /**\n     * Schedule the next updates check.\n     *\n     * The check will only be scheduled so long as there are still entries\n     * being watched. Any data returned in the check will trigger reloads\n     * of parts of the page.\n     */\n    _scheduleCheckUpdates() {\n        if (this._watchedUpdatesTimeout !== null ||\n            this._watchedUpdatesPeriodMS === null) {\n            return;\n        }\n\n        this._watchedUpdatesLastScheduleTime = Date.now();\n        this._watchedUpdatesTimeout = setTimeout(\n            () => {\n                this._watchedUpdatesTimeout = null;\n                this._loadUpdates({\n                    entries: _.pluck(this._watchedEntries, 'entry'),\n                    onDone: this._scheduleCheckUpdates.bind(this),\n                });\n            },\n            this._watchedUpdatesPeriodMS);\n    },\n\n    /**\n     * Load updates from the server.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options that control the types of updates loaded from the\n     *         server.\n     *\n     * Option Args:\n     *     entries (Array):\n     *         A list of entry models that need to be checked for updates.\n     *\n     *     onDone (function, optional):\n     *         Optional function to call after everything is loaded.\n     */\n    _loadUpdates(options={}) {\n        const updatesURL = this.get('updatesURL');\n        const allEntryIDs = {};\n        const entries = options.entries || [];\n\n        const urlQuery = [];\n\n        if (entries.length > 0) {\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                const typeID = entry.get('typeID');\n\n                if (!allEntryIDs.hasOwnProperty(typeID)) {\n                    allEntryIDs[typeID] = [];\n                }\n\n                allEntryIDs[typeID].push(entry.id);\n            }\n\n            const urlEntryTypeIDs = [];\n\n            for (let entryTypeID in allEntryIDs) {\n                if (allEntryIDs.hasOwnProperty(entryTypeID)) {\n                    /*\n                     * Sort the IDs numerically, so that we have a stable URL\n                     * for caching.\n                     */\n                    allEntryIDs[entryTypeID].sort((a, b) => a - b);\n\n                    const entryIDs = allEntryIDs[entryTypeID].join(',');\n                    urlEntryTypeIDs.push(`${entryTypeID}:${entryIDs}`);\n                }\n            }\n\n            urlQuery.push(`entries=${urlEntryTypeIDs.join(';')}`);\n        }\n\n        /*\n         * Like above, sort the URL queries, so that we have a stable URL\n         * for caching.\n         */\n        urlQuery.sort();\n\n        const urlQueryStr = (urlQuery.length > 0\n                             ? `?${urlQuery.join('&')}`\n                             : '');\n\n        Backbone.sync(\n            'read',\n            this,\n            {\n                url: `${updatesURL}${urlQueryStr}`,\n                dataType: 'arraybuffer',\n                noActivityIndicator: true,\n                success: arrayBuffer => this._processUpdatesFromPayload(\n                    arrayBuffer, options.onDone),\n            });\n    },\n\n    /**\n     * Process an updates payload from the server.\n     *\n     * This will parse the payload and then update each of the entries\n     * or other parts of the UI referenced.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     onDone (function, optional):\n     *         The function to call when all updates have been parsed and\n     *         applied.\n     */\n    _processUpdatesFromPayload(arrayBuffer, onDone) {\n        const dataView = new DataView(arrayBuffer);\n        const len = dataView.byteLength;\n        let pos = 0;\n        let totalUpdates = 0;\n        let totalApplied = 0;\n        let done = false;\n\n        const onUpdateLoaded = (metadata, html) => {\n            /*\n             * Based on the update, we can now start updating the UI, if\n             * we can find the matching entry or UI component.\n             */\n            if (metadata.type === 'entry') {\n                this._processEntryUpdate(metadata, html);\n            } else {\n                this._reloadFromUpdate(null, metadata, html);\n            }\n\n            totalApplied++;\n\n            if (done && totalApplied === totalUpdates) {\n                this.trigger('updatesProcessed');\n\n                if (_.isFunction(onDone)) {\n                    onDone();\n                }\n            }\n        };\n\n        while (!done) {\n            const parsed = this._processUpdateFromPayload(arrayBuffer,\n                                                          dataView,\n                                                          pos);\n\n            totalUpdates++;\n            pos = parsed.pos;\n            done = (pos >= len);\n\n            parsed.load(onUpdateLoaded);\n        }\n    },\n\n    /**\n     * Process a single update from the updates payload.\n     *\n     * This will parse out the details for one update, loading in the metadata\n     * and HTML, and then apply that update.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the update content. This takes a\n     *         callback function as an argument containing ``metadata`` and\n     *         ``html`` arguments.\n     */\n    _processUpdateFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the length of the metadata. */\n        const metadataLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the start position of the metadata content for later. */\n        const metadataStart = pos;\n        pos += metadataLen;\n\n        /* Read the length of the HTML content. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the start position of the HTML content for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                const metadataBlob = new Blob([\n                    arrayBuffer.slice(metadataStart,\n                                      metadataStart + metadataLen),\n                ]);\n                const htmlBlob = new Blob([\n                    arrayBuffer.slice(htmlStart, htmlStart + htmlLen),\n                ]);\n\n                RB.DataUtils.readManyBlobsAsStrings(\n                    [metadataBlob, htmlBlob],\n                    (metadata, html) => cb(JSON.parse(metadata), html));\n            },\n        };\n    },\n\n    /**\n     * Process the update to an entry.\n     *\n     * This will locate the existing entry on the page, check if it needs\n     * updating, and then update the entry's attributes and HTML.\n     *\n     * Args:\n     *     metadata (object):\n     *         The metadata for the entry update.\n     *\n     *     html (string):\n     *         The new HTML for the entry.\n     */\n    _processEntryUpdate(metadata, html) {\n        /*\n         * TODO: We'll eventually want to handle new entries we don't\n         *       know about. This would be part of a larger dynamic\n         *       page updates change.\n         */\n        const entry = this.entries.get(metadata.entryID);\n\n        if (!entry) {\n            return;\n        }\n\n        console.assert(entry.get('typeID') === metadata.entryType);\n\n        /* Only reload this entry if its updated timestamp has changed. */\n        if (entry.isUpdated(metadata)) {\n            this._reloadFromUpdate(entry, metadata, html);\n        }\n    },\n\n    /**\n     * Reload a component's attributes and HTML based on an update.\n     *\n     * This will update the attributes for a model, notifying listeners of\n     * each stage of the update so that models and views can react\n     * appropriately.\n     *\n     * If the model has ``beforeApplyUpdate`` and/or ``afterApplyUpdate``\n     * methods, they'll be called before and after any updates are made,\n     * respectively.\n     *\n     * Args:\n     *     model (Backbone.Model):\n     *         The model to update.\n     *\n     *     metadata (object):\n     *         The metadata for the update.\n     *\n     *     html (string):\n     *         The new HTML for the view.\n     */\n    _reloadFromUpdate(model, metadata, html) {\n        this.trigger(`applyingUpdate:${metadata.type}`, metadata, html);\n\n        if (model) {\n            this.trigger(`applyingUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.beforeApplyUpdate)) {\n                model.beforeApplyUpdate(metadata);\n            }\n\n            /* Load any new model data, etags, or updated timestamps. */\n            model.set(model.parse(_.extend(\n                {},\n                model.attributes,\n                metadata.modelData,\n                {\n                    etag: metadata.etag,\n                    updatedTimestamp: metadata.updatedTimestamp,\n                })));\n\n            this.trigger(`appliedModelUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n\n            if (_.isFunction(model.afterApplyUpdate)) {\n                model.afterApplyUpdate(metadata);\n            }\n\n            this.trigger(`appliedUpdate:${metadata.type}:${model.id}`,\n                         metadata, html);\n        }\n\n        this.trigger(`appliedUpdate:${metadata.type}`, metadata, html);\n    },\n});\n"],"mappings":"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"}