{"version":3,"file":"commentEditorModel.js","names":["RB","CommentEditor","Backbone","Model","extend","_","defaults","userSession","UserSession","instance","canDelete","canEdit","undefined","canSave","editing","extraData","comment","dirty","openIssue","get","publishedComments","publishedCommentsType","requireVerification","reviewRequest","richText","text","initialize","on","_updateFromComment","_updateCanEdit","model","reviewRequestEditor","incr","decr","set","_updateState","_setupExtraData","beginEdit","console","assert","deleteComment","destroy","trigger","close","cancel","off","destroyIfEmpty","ExtraData","save","options","context","isFunction","success","error","complete","warn","promiseToCallbacks","newOptions","clone","require_verification","issueOpened","includeTextTypes","oldComment","previous","defaultRichText","requiresVerification","textFields","isEmpty","ready","isNew","ExtraDataMixin"],"sources":["../../../../../static/rb/js/models/commentEditorModel.es6.js"],"sourcesContent":["/**\n * Represents the state for editing a new or existing draft comment.\n *\n * From here, a comment can be created, edited, or deleted.\n *\n * This will provide state on what actions are available on a comment,\n * informative text, dirty states, existing published comments on the\n * same region this comment is on, and more.\n *\n * Attributes:\n *     canDelete (boolean):\n *         Whether the draft comment can be deleted.\n *\n *     canEdit (boolean):\n *         Whether the draft comment can be edited.\n *\n *     canSave (boolean):\n *         Whether the draft comment can be saved.\n *\n *     editing (boolean):\n *         True if the comment is currently being edited.\n *\n *     extraData (object):\n *         The draft state for the comment's extra data.\n *\n *     comment (RB.BaseComment):\n *         The comment model.\n *\n *     dirty (boolean):\n *         True if the draft comment has been edited but not saved.\n *\n *     openIssue (boolean):\n *         Whether the comment opens an issue.\n *\n *     publishedComments (Array of RB.BaseComment):\n *         The thread of previous comments that this draft is a reply to, if\n *         applicable.\n *\n *     publishedCommentsType (string):\n *         The type of comment that this draft is a reply to, if applicable.\n *\n *     reviewRequest (RB.ReviewRequest):\n *         The review request that the comment is on.\n *\n *     richText (boolean):\n *         Whether the comment is formatted in Markdown.\n *\n *     text (string):\n *         The comment's text.\n */\nRB.CommentEditor = Backbone.Model.extend(_.defaults({\n    /**\n     * Return the default values for the model attributes.\n     *\n     * Returns:\n     *     object:\n     *     The default values for the attributes.\n     */\n    defaults() {\n        const userSession = RB.UserSession.instance;\n\n        return {\n            canDelete: false,\n            canEdit: undefined,\n            canSave: false,\n            editing: false,\n            extraData: {},\n            comment: null,\n            dirty: false,\n            openIssue: userSession.get('commentsOpenAnIssue'),\n            publishedComments: [],\n            publishedCommentsType: null,\n            requireVerification: false, // TODO: add a user preference for this.\n            reviewRequest: null,\n            richText: userSession.get('defaultUseRichText'),\n            text: '',\n        };\n    },\n\n    /**\n     * Initialize the comment editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        this.on('change:comment', this._updateFromComment, this);\n        this._updateFromComment();\n\n        /*\n         * Unless a canEdit value is explicitly given, we want to compute\n         * the proper state.\n         */\n        if (this.get('canEdit') === undefined) {\n            reviewRequest.on('change:hasDraft', this._updateCanEdit, this);\n            this._updateCanEdit();\n        }\n\n        this.on('change:dirty', (model, dirty) => {\n            const reviewRequestEditor = this.get('reviewRequestEditor');\n\n            if (reviewRequestEditor) {\n                if (dirty) {\n                    reviewRequestEditor.incr('editCount');\n                } else {\n                    reviewRequestEditor.decr('editCount');\n                }\n            }\n        });\n\n        this.on(\n            'change:openIssue change:requireVerification ' +\n            'change:richText change:text',\n            () => {\n                if (this.get('editing')) {\n                    this.set('dirty', true);\n                    this._updateState();\n                }\n            });\n\n        this._updateState();\n\n        this._setupExtraData();\n    },\n\n    /**\n     * Set the editor to begin editing a new or existing comment.\n     */\n    beginEdit() {\n        console.assert(this.get('canEdit'),\n                       'beginEdit() called when canEdit is false.');\n        console.assert(this.get('comment'),\n                       'beginEdit() called when no comment was first set.');\n\n        this.set({\n            dirty: false,\n            editing: true,\n        });\n\n        this._updateState();\n    },\n\n    /**\n     * Delete the current comment, if it can be deleted.\n     *\n     * This requires that there's a saved comment to delete.\n     *\n     * The editor will be marked as closed, requiring a new call to beginEdit.\n     *\n     * Returns:\n     *     Promise:\n     *     A promise which resolves when the operation is complete.\n     */\n    async deleteComment() {\n        console.assert(this.get('canDelete'),\n                       'deleteComment() called when canDelete is false.');\n\n        const comment = this.get('comment');\n        await comment.destroy();\n        this.trigger('deleted');\n        this.close();\n    },\n\n    /**\n     * Cancel editing of a comment.\n     *\n     * If there's a saved comment and it's been made empty, it will end\n     * up being deleted. Then this editor will be marked as closed,\n     * requiring a new call to beginEdit.\n     */\n    cancel() {\n        const comment = this.get('comment');\n\n        this.off('change:comment', this._updateFromComment, this);\n\n        if (comment) {\n            comment.destroyIfEmpty();\n            this.trigger('canceled');\n        }\n\n        this.close();\n    },\n\n    /**\n     * Close editing of the comment.\n     *\n     * The comment state will be reset, and the \"closed\" event will be\n     * triggered.\n     *\n     * To edit a comment again after closing it, the proper state must be\n     * set again and beginEdit must be called.\n     */\n    close() {\n        /* Set this first, to prevent dirty firing. */\n        this.set('editing', false);\n\n        this.set({\n            comment: null,\n            dirty: false,\n            extraData: new RB.ExtraData(),\n            text: '',\n        });\n\n        this.trigger('closed');\n    },\n\n    /**\n     * Save the comment.\n     *\n     * If this is a new comment, it will be created on the server.\n     * Otherwise, the existing comment will be updated.\n     *\n     * The editor will not automatically be marked as closed. That is up\n     * to the caller.\n     *\n     * Version Changed:\n     *     5.0:\n     *     Deprecated callbacks and added a promise return value.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options for the save operation.\n     *\n     *     context (object, optional):\n     *         The context to use when calling callbacks.\n     *\n     * Returns:\n     *     Promise:\n     *     A promise which resolves when the operation is complete.\n     */\n    async save(options={}, context=undefined) {\n        if (_.isFunction(options.success) ||\n            _.isFunction(options.error) ||\n            _.isFunction(options.complete)) {\n            console.warn('RB.CommentEditor.save was called using ' +\n                         'callbacks. Callers should be updated to use ' +\n                         'promises instead.');\n            return RB.promiseToCallbacks(\n                options, context, newOptions => this.save(newOptions));\n        }\n\n        console.assert(this.get('canSave'),\n                       'save() called when canSave is false.');\n\n        const extraData =  _.clone(this.get('extraData'));\n        extraData.require_verification = this.get('requireVerification');\n\n        const comment = this.get('comment');\n        comment.set({\n            text: this.get('text'),\n            issueOpened: this.get('openIssue'),\n            extraData: extraData,\n            richText: this.get('richText'),\n            includeTextTypes: 'html,raw,markdown',\n        });\n\n        await comment.save();\n\n        this.set('dirty', false);\n        this.trigger('saved');\n    },\n\n    /**\n     * Update the state of the editor from the currently set comment.\n     */\n    async _updateFromComment() {\n        const oldComment = this.previous('comment');\n        const comment = this.get('comment');\n\n        if (oldComment) {\n            oldComment.destroyIfEmpty();\n        }\n\n        if (comment) {\n            const defaultRichText = this.defaults().richText;\n\n            /*\n             * Set the attributes based on what we know at page load time.\n             *\n             * Note that it is *possible* that the comments will have changed\n             * server-side since loading the page (if the user is reviewing\n             * the same diff in two tabs). However, it's unlikely.\n             *\n             * Doing this before the ready() call ensures that we'll have the\n             * text and state up-front and that it won't overwrite what the\n             * user has typed after load.\n             *\n             * Note also that we'll always want to use our default richText\n             * value if it's true, and we'll fall back on the comment's value\n             * if false. This is so that we can keep a consistent experience\n             * when the \"Always edit Markdown by default\" value is set.\n             */\n            this.set({\n                dirty: false,\n                extraData: comment.get('extraData'),\n                openIssue: comment.get('issueOpened') === null\n                           ? this.defaults().openIssue\n                           : comment.get('issueOpened'),\n                requireVerification: comment.requiresVerification(),\n                richText: defaultRichText || !!comment.get('richText'),\n            });\n\n            /*\n             * We'll try to set the one from the appropriate text fields, if it\n             * exists and is not empty. If we have this, then it came from a\n             * previous save. If we don't have it, we'll fall back to \"text\",\n             * which should be normalized content from the initial page load.\n             */\n            const textFields = (comment.get('richText') || !defaultRichText\n                                ? comment.get('rawTextFields')\n                                : comment.get('markdownTextFields'));\n\n            this.set('text',\n                     !_.isEmpty(textFields)\n                     ? textFields.text\n                     : comment.get('text'));\n\n            await comment.ready();\n\n            this._updateState();\n        }\n    },\n\n    /**\n     * Update the canEdit state of the editor.\n     *\n     * This is based on the authentication state of the user, and\n     * whether or not there's an existing draft for the review request.\n     */\n    _updateCanEdit() {\n        const reviewRequest = this.get('reviewRequest');\n        const userSession = RB.UserSession.instance;\n\n        this.set('canEdit',\n                 userSession.get('authenticated') &&\n                 !userSession.get('readOnly') &&\n                 !reviewRequest.get('hasDraft'));\n    },\n\n    /**\n     * Update the capability states of the editor.\n     *\n     * Some of the can* properties will change to reflect the various\n     * actions that can be performed with the editor.\n     */\n    _updateState() {\n        const canEdit = this.get('canEdit');\n        const editing = this.get('editing');\n        const comment = this.get('comment');\n\n        this.set({\n            canDelete: canEdit && editing && comment && !comment.isNew(),\n            canSave: canEdit && editing && this.get('text') !== '',\n        });\n    },\n}, RB.ExtraDataMixin));\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,EAAE,CAACC,aAAH,GAAmBC,QAAQ,CAACC,KAAT,CAAeC,MAAf,CAAsBC,CAAC,CAACC,QAAF,CAAW;EAChD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIA,QAAQ,GAAG;IACP,MAAMC,WAAW,GAAGP,EAAE,CAACQ,WAAH,CAAeC,QAAnC;IAEA,OAAO;MACHC,SAAS,EAAE,KADR;MAEHC,OAAO,EAAEC,SAFN;MAGHC,OAAO,EAAE,KAHN;MAIHC,OAAO,EAAE,KAJN;MAKHC,SAAS,EAAE,EALR;MAMHC,OAAO,EAAE,IANN;MAOHC,KAAK,EAAE,KAPJ;MAQHC,SAAS,EAAEX,WAAW,CAACY,GAAZ,CAAgB,qBAAhB,CARR;MASHC,iBAAiB,EAAE,EAThB;MAUHC,qBAAqB,EAAE,IAVpB;MAWHC,mBAAmB,EAAE,KAXlB;MAWyB;MAC5BC,aAAa,EAAE,IAZZ;MAaHC,QAAQ,EAAEjB,WAAW,CAACY,GAAZ,CAAgB,oBAAhB,CAbP;MAcHM,IAAI,EAAE;IAdH,CAAP;EAgBH,CA3B+C;;EA6BhD;AACJ;AACA;EACIC,UAAU,GAAG;IACT,MAAMH,aAAa,GAAG,KAAKJ,GAAL,CAAS,eAAT,CAAtB;IAEA,KAAKQ,EAAL,CAAQ,gBAAR,EAA0B,KAAKC,kBAA/B,EAAmD,IAAnD;;IACA,KAAKA,kBAAL;IAEA;AACR;AACA;AACA;;;IACQ,IAAI,KAAKT,GAAL,CAAS,SAAT,MAAwBP,SAA5B,EAAuC;MACnCW,aAAa,CAACI,EAAd,CAAiB,iBAAjB,EAAoC,KAAKE,cAAzC,EAAyD,IAAzD;;MACA,KAAKA,cAAL;IACH;;IAED,KAAKF,EAAL,CAAQ,cAAR,EAAwB,CAACG,KAAD,EAAQb,KAAR,KAAkB;MACtC,MAAMc,mBAAmB,GAAG,KAAKZ,GAAL,CAAS,qBAAT,CAA5B;;MAEA,IAAIY,mBAAJ,EAAyB;QACrB,IAAId,KAAJ,EAAW;UACPc,mBAAmB,CAACC,IAApB,CAAyB,WAAzB;QACH,CAFD,MAEO;UACHD,mBAAmB,CAACE,IAApB,CAAyB,WAAzB;QACH;MACJ;IACJ,CAVD;IAYA,KAAKN,EAAL,CACI,iDACA,6BAFJ,EAGI,MAAM;MACF,IAAI,KAAKR,GAAL,CAAS,SAAT,CAAJ,EAAyB;QACrB,KAAKe,GAAL,CAAS,OAAT,EAAkB,IAAlB;;QACA,KAAKC,YAAL;MACH;IACJ,CARL;;IAUA,KAAKA,YAAL;;IAEA,KAAKC,eAAL;EACH,CAxE+C;;EA0EhD;AACJ;AACA;EACIC,SAAS,GAAG;IACRC,OAAO,CAACC,MAAR,CAAe,KAAKpB,GAAL,CAAS,SAAT,CAAf,EACe,2CADf;IAEAmB,OAAO,CAACC,MAAR,CAAe,KAAKpB,GAAL,CAAS,SAAT,CAAf,EACe,mDADf;IAGA,KAAKe,GAAL,CAAS;MACLjB,KAAK,EAAE,KADF;MAELH,OAAO,EAAE;IAFJ,CAAT;;IAKA,KAAKqB,YAAL;EACH,CAzF+C;;EA2FhD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMK,aAAN,GAAsB;IAClBF,OAAO,CAACC,MAAR,CAAe,KAAKpB,GAAL,CAAS,WAAT,CAAf,EACe,iDADf;IAGA,MAAMH,OAAO,GAAG,KAAKG,GAAL,CAAS,SAAT,CAAhB;IACA,MAAMH,OAAO,CAACyB,OAAR,EAAN;IACA,KAAKC,OAAL,CAAa,SAAb;IACA,KAAKC,KAAL;EACH,CA9G+C;;EAgHhD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,MAAM,GAAG;IACL,MAAM5B,OAAO,GAAG,KAAKG,GAAL,CAAS,SAAT,CAAhB;IAEA,KAAK0B,GAAL,CAAS,gBAAT,EAA2B,KAAKjB,kBAAhC,EAAoD,IAApD;;IAEA,IAAIZ,OAAJ,EAAa;MACTA,OAAO,CAAC8B,cAAR;MACA,KAAKJ,OAAL,CAAa,UAAb;IACH;;IAED,KAAKC,KAAL;EACH,CAlI+C;;EAoIhD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIA,KAAK,GAAG;IACJ;IACA,KAAKT,GAAL,CAAS,SAAT,EAAoB,KAApB;IAEA,KAAKA,GAAL,CAAS;MACLlB,OAAO,EAAE,IADJ;MAELC,KAAK,EAAE,KAFF;MAGLF,SAAS,EAAE,IAAIf,EAAE,CAAC+C,SAAP,EAHN;MAILtB,IAAI,EAAE;IAJD,CAAT;IAOA,KAAKiB,OAAL,CAAa,QAAb;EACH,CAzJ+C;;EA2JhD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMM,IAAN,GAA0C;IAAA,IAA/BC,OAA+B,uEAAvB,EAAuB;IAAA,IAAnBC,OAAmB,uEAAXtC,SAAW;;IACtC,IAAIP,CAAC,CAAC8C,UAAF,CAAaF,OAAO,CAACG,OAArB,KACA/C,CAAC,CAAC8C,UAAF,CAAaF,OAAO,CAACI,KAArB,CADA,IAEAhD,CAAC,CAAC8C,UAAF,CAAaF,OAAO,CAACK,QAArB,CAFJ,EAEoC;MAChChB,OAAO,CAACiB,IAAR,CAAa,4CACA,8CADA,GAEA,mBAFb;MAGA,OAAOvD,EAAE,CAACwD,kBAAH,CACHP,OADG,EACMC,OADN,EACeO,UAAU,IAAI,KAAKT,IAAL,CAAUS,UAAV,CAD7B,CAAP;IAEH;;IAEDnB,OAAO,CAACC,MAAR,CAAe,KAAKpB,GAAL,CAAS,SAAT,CAAf,EACe,sCADf;;IAGA,MAAMJ,SAAS,GAAIV,CAAC,CAACqD,KAAF,CAAQ,KAAKvC,GAAL,CAAS,WAAT,CAAR,CAAnB;;IACAJ,SAAS,CAAC4C,oBAAV,GAAiC,KAAKxC,GAAL,CAAS,qBAAT,CAAjC;IAEA,MAAMH,OAAO,GAAG,KAAKG,GAAL,CAAS,SAAT,CAAhB;IACAH,OAAO,CAACkB,GAAR,CAAY;MACRT,IAAI,EAAE,KAAKN,GAAL,CAAS,MAAT,CADE;MAERyC,WAAW,EAAE,KAAKzC,GAAL,CAAS,WAAT,CAFL;MAGRJ,SAAS,EAAEA,SAHH;MAIRS,QAAQ,EAAE,KAAKL,GAAL,CAAS,UAAT,CAJF;MAKR0C,gBAAgB,EAAE;IALV,CAAZ;IAQA,MAAM7C,OAAO,CAACgC,IAAR,EAAN;IAEA,KAAKd,GAAL,CAAS,OAAT,EAAkB,KAAlB;IACA,KAAKQ,OAAL,CAAa,OAAb;EACH,CAjN+C;;EAmNhD;AACJ;AACA;EACI,MAAMd,kBAAN,GAA2B;IACvB,MAAMkC,UAAU,GAAG,KAAKC,QAAL,CAAc,SAAd,CAAnB;IACA,MAAM/C,OAAO,GAAG,KAAKG,GAAL,CAAS,SAAT,CAAhB;;IAEA,IAAI2C,UAAJ,EAAgB;MACZA,UAAU,CAAChB,cAAX;IACH;;IAED,IAAI9B,OAAJ,EAAa;MACT,MAAMgD,eAAe,GAAG,KAAK1D,QAAL,GAAgBkB,QAAxC;MAEA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MACY,KAAKU,GAAL,CAAS;QACLjB,KAAK,EAAE,KADF;QAELF,SAAS,EAAEC,OAAO,CAACG,GAAR,CAAY,WAAZ,CAFN;QAGLD,SAAS,EAAEF,OAAO,CAACG,GAAR,CAAY,aAAZ,MAA+B,IAA/B,GACE,KAAKb,QAAL,GAAgBY,SADlB,GAEEF,OAAO,CAACG,GAAR,CAAY,aAAZ,CALR;QAMLG,mBAAmB,EAAEN,OAAO,CAACiD,oBAAR,EANhB;QAOLzC,QAAQ,EAAEwC,eAAe,IAAI,CAAC,CAAChD,OAAO,CAACG,GAAR,CAAY,UAAZ;MAP1B,CAAT;MAUA;AACZ;AACA;AACA;AACA;AACA;;MACY,MAAM+C,UAAU,GAAIlD,OAAO,CAACG,GAAR,CAAY,UAAZ,KAA2B,CAAC6C,eAA5B,GACEhD,OAAO,CAACG,GAAR,CAAY,eAAZ,CADF,GAEEH,OAAO,CAACG,GAAR,CAAY,oBAAZ,CAFtB;MAIA,KAAKe,GAAL,CAAS,MAAT,EACS,CAAC7B,CAAC,CAAC8D,OAAF,CAAUD,UAAV,CAAD,GACEA,UAAU,CAACzC,IADb,GAEET,OAAO,CAACG,GAAR,CAAY,MAAZ,CAHX;MAKA,MAAMH,OAAO,CAACoD,KAAR,EAAN;;MAEA,KAAKjC,YAAL;IACH;EACJ,CA9Q+C;;EAgRhD;AACJ;AACA;AACA;AACA;AACA;EACIN,cAAc,GAAG;IACb,MAAMN,aAAa,GAAG,KAAKJ,GAAL,CAAS,eAAT,CAAtB;IACA,MAAMZ,WAAW,GAAGP,EAAE,CAACQ,WAAH,CAAeC,QAAnC;IAEA,KAAKyB,GAAL,CAAS,SAAT,EACS3B,WAAW,CAACY,GAAZ,CAAgB,eAAhB,KACA,CAACZ,WAAW,CAACY,GAAZ,CAAgB,UAAhB,CADD,IAEA,CAACI,aAAa,CAACJ,GAAd,CAAkB,UAAlB,CAHV;EAIH,CA9R+C;;EAgShD;AACJ;AACA;AACA;AACA;AACA;EACIgB,YAAY,GAAG;IACX,MAAMxB,OAAO,GAAG,KAAKQ,GAAL,CAAS,SAAT,CAAhB;IACA,MAAML,OAAO,GAAG,KAAKK,GAAL,CAAS,SAAT,CAAhB;IACA,MAAMH,OAAO,GAAG,KAAKG,GAAL,CAAS,SAAT,CAAhB;IAEA,KAAKe,GAAL,CAAS;MACLxB,SAAS,EAAEC,OAAO,IAAIG,OAAX,IAAsBE,OAAtB,IAAiC,CAACA,OAAO,CAACqD,KAAR,EADxC;MAELxD,OAAO,EAAEF,OAAO,IAAIG,OAAX,IAAsB,KAAKK,GAAL,CAAS,MAAT,MAAqB;IAF/C,CAAT;EAIH;;AA/S+C,CAAX,EAgTtCnB,EAAE,CAACsE,cAhTmC,CAAtB,CAAnB"}