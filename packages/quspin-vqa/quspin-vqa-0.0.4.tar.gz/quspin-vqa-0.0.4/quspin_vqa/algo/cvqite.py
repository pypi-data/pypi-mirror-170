from quspin_vqa.algo.qaoa import QAOA
import scipy.linalg as la
import numpy as np
import scipy.optimize as opt
from quspin_vqa.utils import hamiltonian_s
from itertools import product
import random 
from quspin_vqa.utils import normalize
import wandb

class CVQITE(QAOA):
    """Compact Variational QITE ansatz

    Use the QITE ansatz to solve the optimization problem. Here, the ansatz is low rank approximation of the complete ansatz.
    """

    def __init__(self, physics_system, q, ham_pool_length, N_c, pauli_site):
        """Initialize the CVQITE ansatz.

        Args:
            physics_system (PhysicsSystem): the physics system.
            q (int): the number of qubits.
            ham_pool_length (int): the length of the hamiltonian pool.
            N_c (int): the number of compact hamiltonians.
            pauli_site (int): the numbers of the sites the pauli operator acts on.
        """
        self._name = 'cv-QITE'
        self.physics_system = physics_system
        self._extract_physics_system()
        self.q = q
        assert self.q % 2 == 0, "The number of QAOA length should be even numbers."
        self.p = q // 2
        self.ham_pool_length = ham_pool_length
        self.N_c = N_c
        self.params = None

        # generate the pauli hamiltonian pool
        self._pauli_pool = ['I', 'x', 'y', 'z']
        self.pauli_site = pauli_site
        self._generate_ham_pool()
    
    def _generate_ham_pool(self):
        """Generate the pool of hamiltonians.

        Returns:
            list: the pool of hamiltonians. (in terms of sparse matrices [csc format])
        """
        # hamiltonian pool 
        # TODO: (jim) change the hamiltonian pool to be 
        # the pool of the hamiltonians that are generated by the
        # subset of the hamiltonians in the hamiltonian pool 

        # extract the basis and the system size L
        basis = self.physics_system.basis
        L = self.physics_system.L
        sites = list(range(L))

        pauli_str_list = list(map(lambda x: ''.join(x), product(self._pauli_pool, repeat=self.pauli_site)))

        pauli_str_list = random.sample(pauli_str_list, k=self.ham_pool_length)
        print('the pauli string pattern: ', ' '.join(pauli_str_list))

        ham_pool = []
        for pauli_str in pauli_str_list:
            static = [[pauli_str, [[1, *sites]]]]
            ham_pool.append(hamiltonian_s(static, [], basis=basis).tocsc())
        
        self.ham_pool = ham_pool
        self.ham_pool_length = len(ham_pool)
        
    def _initial_x0(self):
        """Generate the initial guess of the parameters.
        
        Note that here the params are the concatenation of the two parts, i.e. params = [params_u, params_v].
        """
        x0 = np.random.uniform(0, 2 * np.pi, (self.q +  self.ham_pool_length) * self.N_c)
        return normalize(x0, normal_val= (self.q +  self.ham_pool_length) * self.N_c)

    @property
    def initial_guess(self):
        """Generate the initial guess for the sovler
        """
        return self._initial_x0()
    
    def evolve(self, params_u, params_v):
        """Evolve the system with the given parameters.

        Args:
            variational_ansatz (tuple): the ordering of the hamiltonians
            params (np.ndarray): the parameters of the variational ansatz.
                Note that params = [params_u, params_v], c_a,j = sum_k u_a,k v_j,k
                H_k^c = sum_a c_a,k H_a
                
                N_c (int): the number of compact hamiltonians. 
            
        """
        u = np.copy(self.psi_initial)

        assert len(params_u) == self.N_c * self.ham_pool_length, "The number of parameters should be the multiple of hamiltonian pool length."
        compact_ham_pool = [ sum([ c * h for c, h in zip(params_u[i::self.N_c], self.ham_pool)])  for i in range(self.N_c)] 
        
        N_q = len(params_v) // self.N_c

        assert len(params_v) % self.N_c == 0, "The number of parameters should be the multiple of hamiltonian pool length."

        for i in range(N_q):
            mat = sum([ c * h for c, h in zip(params_v[i * self.N_c: (i + 1) * self.N_c], compact_ham_pool)])
            expmat = la.expm(-1j * mat).toarray()
            u = np.dot(expmat, u)
        return u
        
    # def evolve(self, params_u, params_v):
    #     """Evolve the system with the given parameters.

    #     Args:
    #         variational_ansatz (tuple): the ordering of the hamiltonians
    #         params (np.ndarray): the parameters of the variational ansatz.
    #     """
    #     u = np.copy(self.psi_initial)

    #     assert len(params_u) == self.N_c * self.ham_pool_length == 0, "The number of parameters should be the multiple of hamiltonian pool length."
    #     compact_ham_pool = [ sum([ c * h for c, h in zip(params_u[i::self.N_c], self.ham_pool)])  for i in range(self.N_c)] 
        
    #     N_q = len(params_v) // self.N_c

    #     assert len(params_v) % self.N_c == 0, "The number of parameters should be the multiple of hamiltonian pool length."

    #     for i in range(N_q):
    #         mat = sum([ c * h for c, h in zip(params_v[i * self.N_c: (i + 1) * self.N_c], compact_ham_pool)])
    #         expmat = la.expm(-1j * mat)
    #         u = np.dot(expmat, u)
    #     return u
        
    def fidelity(self, *params):
        """Compute the fidelity between the target state and the evolved state.
        """
        u = self.evolve(*params)
        wandb.log({'fidelity': self._compute_fidelity(u)})
        return self._compute_fidelity(u)

    def expected_energy(self, *params):
        """Compute the expected energy of the evolved state.
        """
        u = self.evolve(*params)
        return self._compute_expected_energy(u)

    def get_reward(self, params, reward_type='fidelity'):
        """Compute the reward of the evolved state.
        
        args: 
            params (np.ndarray): the parameters of the variational ansatz. Note that 
            params is the concatenation of the two parts, i.e. params = [params_u, params_v]. 
        """
        params = self._split_params(params)
        if reward_type == 'fidelity':
            return self.fidelity(*params)
        elif reward_type == 'energy':
            return - self.expected_energy(*params)
        else:
            raise NotImplementedError("The reward type is not supported.")

    # TODO: add the noise reward (maybe to the noise module, which is supposed to add more method to the class)

    @property
    def name(self):
        return self._name
    
    
    def _split_params(self, params):
        """Split the parameters into the parameters of the compact hamiltonians and the parameters of the variational ansatz.
        """
        params_u = params[:self.N_c * self.ham_pool_length]
        params_v = params[self.N_c * self.ham_pool_length:]
        return params_u, params_v
