--[[
    Influence from https://github.com/luapower/mmap/blob/master/mmap.lua
]]

local ffi = require 'ffi'
local bit = require 'bit'
local istype in ffi
local _C in MAD --For speed
local tostring, imatrix, matrix, cmatrix in MAD
local is_matrix, is_cmatrix, is_imatrix, is_string, is_number, is_nil, is_element, is_boolean, is_table in MAD.typeid
local ceil in math
local type, assert, error, ipairs, tonumber, tostring, table, string, rawequal = --Not all necessary (check)
      type, assert, error, ipairs, tonumber, tostring, table, string, rawequal    --Any others here?

ffi.cdef 
[[ 
typedef signed int ssize_t;
typedef int64_t off64_t;
typedef int64_t pid_t;
typedef unsigned short mode_t;
int msync(void *addr, size_t len, int flags); 
void *mmap (void *addr, size_t len,  int prot, int flags, int fildes, off64_t offset);
int shm_open(const char *name, int oflag, mode_t mode); 
int printf(const char *format, ...); //For debugging
int munmap(void *addr, size_t len);
int ftruncate(int fildes, off64_t length);
int close(int fd);
int getpagesize(void);
off64_t lseek(int fd, off64_t offset, int whence);
ssize_t write(int fd, const void *buf, size_t count);
int open(const char *pathname, int flags);
]]

------------------MMAPP ACESS FLAGS------------------- (From https://github.com/luapower/mmap/blob/master/mmap.lua)

--mmap() access flags
local PROT_READ  = 1
local PROT_WRITE = 2

--mmap() parameter flags
local osx = ffi.os == 'OSX'
local MAP_SHARED  = 1
local MAP_PRIVATE = 2 --copy-on-write
local MAP_FIXED   = 0x0010
local MAP_ANON    = osx and 0x1000 or 0x0020

--shm_open() oflags --Need to verify these
local O_RDONLY    = 0
local O_WRONLY    = 1
local O_RDWR      = 2
local O_NONBLOCK  = osx and 0x00004 or tonumber("04000", 8)
local O_CREAT     = osx and 0x00200 or tonumber('00100', 8)
local O_SYNC      = osx and 0x00080 or tonumber('4010000', 8)
local O_TRUNC     = osx and 0x00400 or tonumber('01000', 8)

--msync() flags
local MS_ASYNC      = 1
-- local MS_INVALIDATE = 2
local MS_SYNC       = osx and 0x0010 or 4

-----------------------lseek flags------------------ (Only for linux?)
local SEEK_SET = 0	-- Seek from beginning of file.
local SEEK_CUR = 1	-- Seek from current position.
local SEEK_END = 2	-- Seek from end of file.
local SEEK_DATA = 3	-- Seek to next data.
local SEEK_HOLE	= 4	-- Seek to next hole.

local PAGE_SIZE = _C.getpagesize()

--List of identifier types
local STRING_VAL    = 1
local IMATRIX_VAL   = 2
local MATRIX_VAL    = 3
local CMATRIX_VAL   = 4
local SCALAR_VAL    = 5 
--Add more here

-- local file_size = 10000000
local writeFildes = nil
local readFildes = nil
local pipeDir = nil
local pipe = nil
local pipeFd = nil
local pagesWritten = 0
local pipeNumber = 0
local pageUpTo = 0
local pyCommandFormat = "pyCommand:"
local pyInstructionFormat = "pyInstruction:"
----------------Necessary??-------------------------
local function sleep(time) --For debugging
    local start = os.clock()
    while os.clock() - start < time do end
end
-----------------------------------------------------
local function getDimsAndSize(offset)
    local dimsAddress = _C.mmap(nil, 8, PROT_READ, MAP_SHARED, readFildes, offset)
    local dims = imatrix(2, 1)
    ffi.copy(dims.data, dimsAddress, 8)
    local dataSize = 8 * dims[1] * dims[2]
    return dims, dataSize
end
----------------------------------READING------------------------------
local function readSharedMemory(dataFrame, dataSize, offset)
    --Read the data
    local dataAddress = _C.mmap(nil, dataSize, PROT_READ, MAP_SHARED, readFildes, offset)
    ffi.copy(dataFrame.data, dataAddress, dataSize)
    local numPagesUsed = ceil(dataSize/PAGE_SIZE)
    local totalBytes = numPagesUsed * PAGE_SIZE
    _C.munmap(dataAddress, totalBytes)
    return dataFrame, numPagesUsed --Other way to produce varargs?
end

local function chkPage(pageToReadFrom)
    if pageToReadFrom ~= pageUpTo then
        pageUpTo = pageToReadFrom
        print("WARNING SHARED MEMORY MISALLIGNED, PLEASE REPORT")
    end
end

local function readCMatrix(dims, pageToReadFrom)
    chkPage(pageToReadFrom)
    local offset = pageUpTo * PAGE_SIZE
    local fileContents = {}
    local dataSize = 8 * dims[1] * dims[2] * 2
    local dataFrame = cmatrix(dims[1], dims[2])
    local data, numPagesUsed = readSharedMemory(dataFrame, dataSize, offset)
    pageUpTo = pageUpTo + numPagesUsed 
    return data
end

local function readMatrix(dims, pageToReadFrom)
    chkPage(pageToReadFrom)
    local offset = pageUpTo * PAGE_SIZE
    local fileContents = {}
    local dataSize = 8 * dims[1] * dims[2]
    local dataFrame = matrix(dims[1], dims[2])
    local data, numPagesUsed = readSharedMemory(dataFrame, dataSize, offset)
    pageUpTo = pageUpTo + numPagesUsed 
    return data
end

local function readIMatrix(dims, pageToReadFrom)
    chkPage(pageToReadFrom)
    local offset = pageUpTo * PAGE_SIZE
    local fileContents = {}
    local dataSize = 8 * dims[1] * dims[2] / 2
    local dataFrame = imatrix(dims[1], dims[2])
    local data, numPagesUsed = readSharedMemory(dataFrame, dataSize, offset)
    pageUpTo = pageUpTo + numPagesUsed 
    return data
end

local function readScalar(dims, pageToReadFrom)
    return readMatrix(dims, pageToReadFrom)[1]
end

-----------------------------------------------------------------------

--------------------------WRITING--------------------------------------
local function setupPipe(pipeName)
    pipeDir = pipeName
end

local function openPipe(pipeName)
    pipe = assert(io.open(pipeName, "w"))
    pipe:setvbuf("no")
end

local function writeToPipe(string)
    pipe:write(string)
end

local function openSharedMemory(filename, write) 
    if not writeFildes and write then
        writeFildes = _C.shm_open(filename, O_RDWR, 0)-- tonumber('444', 8) + tonumber('222', 8))  (read-write)
    elseif not readFildes and not write then
        readFildes = _C.shm_open(filename, O_RDWR, 384)
    end
end

local function mmapWrite(data) --rename data and dataSize?
    pagesWritten = pageUpTo
    offset = pageUpTo * PAGE_SIZE
    local dataSize = ffi.sizeof(data)
    file_size = tonumber(_C.lseek(writeFildes, 0, SEEK_END))
    _C.lseek(writeFildes, 0, SEEK_SET)
    if dataSize + offset + 2*PAGE_SIZE > file_size then --This increases the RAM Usage (if necessary)
        writeToPipe(pyCommandFormat.."self.resetShmSafely(False)\n" .. "continue")
        io.read(8)
        offset = 0
        pagesWritten = 0
        pageUpTo = 0
    end
    local dataAddress = _C.mmap(nil, dataSize, bit.bor(PROT_READ, PROT_WRITE), MAP_SHARED, writeFildes, offset)
    ffi.copy(dataAddress, data.data, dataSize)
    _C.munmap(dataAddress, dataSize)
    pageUpTo = pageUpTo + ceil(dataSize/PAGE_SIZE)

end

local function sortData(data)
    local command = pyCommandFormat
    -- Not a fan of this if statment, is there a better way?    
    if is_number(data) then
        data = matrix(1):fill(data)
        command = command .. "self.readMADScalar(np.float64, "
    elseif is_boolean(data) then
        data = matrix(1):fill(data and 1 or 0)
        command = command .. "self.readMADScalar(bool, "
    elseif is_string(data) then 
        local stringAsMatrix = imatrix(1,data:len()) 
        for i = 1, #data do
            stringAsMatrix[i] = string.byte(data:sub(i,i))
        end
        data = stringAsMatrix -- Had problems with strings so matrix of ascii
        command = command .. "self.readMADString(["..data.nrow..","..data.ncol.."],"
    elseif is_imatrix(data) then
        command = command .. "self.readMADMatrix(np.int32,["..data.nrow..","..data.ncol.."], "
    elseif is_matrix(data) then
        command = command .. "self.readMADMatrix(np.float64,["..data.nrow..","..data.ncol.."], "
    elseif is_cmatrix(data) then
        command = command .. "self.readMADMatrix(np.complex128,["..data.nrow..","..data.ncol.."], "
    elseif is_table(data) then 
        command = command .. "self.getMADTable("
        data = matrix(1):fill(0)
    else
        writeToPipe(data)
    end 
    return data, command
end


local function sharedata(dataList) --Can't do tables of tables
    writeToPipe(pyInstructionFormat .. "Save\n")
    if #dataList == 0 then 
        writeToPipe(pyCommandFormat .. 'None\n')
    end 
    for _, data in ipairs(dataList) do 
        data, command = sortData(data)
        mmapWrite(data)
        writeToPipe(command .. pagesWritten..")\n")
    end
end

local function sharetable(table) --Ignores named tables IMPROVE!
    data = table[1]
    dataList = {}
    commandList = {}
    -- for i, v in pairs(table) do print(i, v) end
    for i, v in ipairs(data) do 
        newValue, newCmd = sortData(v)
        dataList[i]= newValue
        commandList[i] = newCmd
    end
    writeToPipe(pyInstructionFormat .. "Save\n")
    writeToPipe(pyCommandFormat .. "self.readMADTable(".. #dataList..")\n")
    for i, v in ipairs(dataList) do 
        mmapWrite(v)
        writeToPipe(commandList[i] .. pagesWritten..")\n")
    end
end

local function close()
    if writeFildes then
        _C.close(writeFildes)
        writeFildes = nil
    end
    if readFildes then
        _C.close(readFildes)
        readFildes = nil
    end
end

local function safelyCloseMemory() --Will also convert pointers into memory in the future
    closeSharedMemory()
    pageUpTo = 0
end
----------------------------end-----------------------------
return{ 
    sharedata = sharedata, 
    sharetable = sharetable,
    readCMatrix = readCMatrix,
    readIMatrix = readIMatrix,
    readMatrix = readMatrix,
    readScalar = readScalar,
    openSharedMemory = openSharedMemory,
    close = close,
    safelyCloseMemory = safelyCloseMemory,
    openPipe = openPipe,
    writeToPipe = writeToPipe,
}